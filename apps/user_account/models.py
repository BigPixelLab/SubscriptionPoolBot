from __future__ import annotations

import datetime
import typing

from utils import database


class User(typing.NamedTuple):
    user_id: int
    """ Chat user ID """
    last_interaction: datetime.datetime
    """ Last user interaction with the bot """
    last_bill_id: str
    """ Qiwi bill id of the last bill generated by the user """
    last_bill_message_id: int
    """ Telegram ID of the last bill message generated by the user """
    reserved_coupon: str
    """ Code of the reserved for last bill coupon """
    last_bill_expire_after: datetime.datetime
    """ Date and time then last generated bill is going to expire (after this time coupon reservation is invalid) """

    @classmethod
    def get_last_bill_info(cls, user_id: int) -> tuple[str, int] | None:
        result = database.single_row(
            """
                select last_bill_id, last_bill_message_id from "User"
                where user_id = %(user_id)s
            """,
            f'Getting last bill info for user {user_id}',
            user_id=user_id
        )

        if result is None:
            return None

        bill_id, message_id = result
        return bill_id, message_id

    @classmethod
    def set_bill_info(cls, user_id: int, bill_id: str, message_id: int):
        database.execute(
            """
                insert into "User" (
                    user_id,
                    last_interaction,
                    last_bill_id,
                    last_bill_message_id
                ) values (
                    %(user_id)s,
                    %(last_inter)s,
                    %(bill_id)s,
                    %(message_id)s
                ) on conflict (user_id) do update set
                    last_interaction = excluded.last_interaction,
                    last_bill_id = excluded.last_bill_id,
                    last_bill_message_id = excluded.last_bill_message_id
            """,
            f'Updating last_unpaid_bill for user {user_id}',
            last_inter=datetime.datetime.now(),
            message_id=message_id,
            user_id=user_id,
            bill_id=bill_id,
        )

    @classmethod
    def after_purchase(cls, user_id: int):
        """ Очищает информацию о последнем сгенерированном счёте
            и снимает резервацию купонов """
        database.execute(
            """
                insert into "User" (
                    user_id,
                    last_interaction
                ) values (
                    %(user_id)s,
                    %(last_inter)s
                ) on conflict (user_id) do update set
                    last_interaction = excluded.last_interaction,
                    last_bill_id = null,
                    last_bill_message_id = null,
                    reserved_coupon = null,
                    last_bill_expire_after = null
            """,
            f'Cleaning up after purchase for {user_id}',
            last_inter=datetime.datetime.now(),
            user_id=user_id
        )

    @classmethod
    def set_user_last_interaction(cls, user_id: int, time: datetime.datetime):
        return database.execute(
            """
                insert into "User" (user_id, last_interaction)
                values (%(user_id)s, %(last_interaction)s)
                on conflict (user_id) do update set
                    last_interaction = excluded.last_interaction
            """,
            f'Setting user {user_id} last interaction',
            user_id=user_id,
            last_interaction=time
        )

    @classmethod
    def get_all(cls) -> list[int]:
        return database.fetch_values(
            """
                select user_id from "User"
            """,
            'Getting list of users to send mailing'
        )
